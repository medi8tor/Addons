local L,N=...local u=HeroDBC.DBC local b,O=HeroCache,N.Utils local y=N.Unit local P,H,l=y.Player,y.Pet,y.Target local f,j=y.Focus,y.MouseOver local e,W,r=y.Arena,y.Boss,y.Nameplate local S,M=y.Party,y.Raid local o=N.Spell local t=N.Item local h=GetTime local s=pairs local E=C_Spell.GetSpellCastCount local q=C_Spell.GetSpellInfo local p=C_Spell.GetSpellPowerCost local D=C_Spell.IsSpellUsable local X=IsPlayerSpell local A=IsSpellKnown function o.ID(L)return L.SpellID end function o.Type(L)return L.SpellType end function o.Name(L)return L.SpellName end function o.MinimumRange(L)return L.MinimumRange end function o.MaximumRange(L)return L.MaximumRange end function o.IsMelee(L)return L.IsMelee end function o.InfoByID(L)return q(L:ID())end function o.InfoByName(L)return q(L:Name())end function o.TimeSinceLastCast(L)return h()-L.LastCastTime end function o.TimeSinceLastDisplay(L)return h()-L.LastDisplayTime end function o.TimeSinceLastAppliedOnPlayer(L)return h()-L.LastAppliedOnPlayerTime end function o.TimeSinceLastRemovedOnPlayer(L)return h()-L.LastRemovedFromPlayerTime end function o.RegisterDamageFormula(N,L)N.DamageFormula=L end function o.Damage(L)return L.DamageFormula and L.DamageFormula()or 0 end function o.IsAvailable(N,L)return L and A(N.SpellID,true)or X(N.SpellID)end function o.IsKnown(N,L)return A(N.SpellID,L and true or false)end function o.IsPetKnown(L)return L:IsKnown(true)end function o.IsUsable(L)return D(L.SpellID)end function o.IsUsableP(N,L)local u,b=N:IsUsable()if u==false and b==false then return false end local O=N:CostTable()or{}local y=true if#O>0 then local u=1 while y==true and u<=#O do local b=O[u]local H=b.type if P.PredictedResourceMap[H]()<(N.CustomCost and(N.CustomCost[H]and N.CustomCost[H]())or b.minCost)+(L or 0)then y=false end u=u+1 end end return y end function o.IsUsablePPool(N,L)local u=N:CostTable()if#u>0 then local b=u[1]local O=b.type return P.PredictedResourceMap[O]()<(N.CustomCost and(N.CustomCost[O]and N.CustomCost[O]())or b.minCost)+(L or 0)else return true end end function o.IsLearned(L)return b.Persistent.SpellLearned[L:Type()][L:ID()]or false end function o.Count(L)return E(L:ID())end function o.IsCastable(N,L)return N:IsLearned()and N:CooldownUp(L)end function o.IsReady(L)return L:IsCastable()and L:IsUsableP()end function o.CastTime(L)local N=(L:InfoByID()).castTime return N and N/1000 or 0 end function o.ExecuteTime(L)local N=L:CastTime()local u=P:GCD()return N>u and N or u end function o.ExecuteRemains(L)if not P:IsCasting(L)then return 0 end local N=P:CastRemains()local u=P:GCDRemains()return N>u and N or u end function o.CostTable(L)local N=L.SpellID local u=b.SpellInfo[N]if not u then u={}b.SpellInfo[N]=u end local O=u.CostTable if not O then O=p(N)u.CostTable=O end return O end function o.CostInfo(u,L,N)if not N or type(N)~="\115\116\114\105\110\103"then error("\073\110\118\097\108\105\100 \075\101\121 \116\121\112\101\046")end local b=u:CostTable()if not L and(b and(#b>1 and(b[1].type==4 and b[2].type==3)))then L=2 else L=L or 1 end return b and(b[L]and b[L][N])or nil end function o.Cost(N,L)local u=N:CostInfo(L,"\099\111\115\116")return u or 0 end function o.TalentRank(L)return b.Persistent.Talents[L.SpellID]or 0 end do local L=u.SpellTickTime local b=N.SpecID_ClassesSpecs function o.FilterTickTime(u,N)local O={}for N,u in s(b[N][1])do for N,u in s(u)do local b=u:ID()local y=L[b][1]if y~=nil then O[b]=y end end end L=O end function o.BaseTickTime(N)local u=L[N:ID()]if not u or u==0 then return 0 end return u[1]/1000 end function o.TickTime(N)local u=N:BaseTickTime()if not u or u==0 then return 0 end local b=L[N:ID()][2]if b then return u*P:SpellHaste()end return u end end do local L=u.SpellDuration function o.BaseDuration(N)local u=L[N:ID()]if not u or u==0 then return 0 end return u[1]/1000 end function o.MaxDuration(N)local u=L[N.SpellID]if not u or u==0 then return 0 end return u[2]/1000 end function o.PandemicThreshold(L)local N=L:BaseDuration()if not N or N==0 then return 0 end return N*.3 end end do local L=u.SpellGCD function o.GCD(N)local u=L[N.SpellID]if not u or u==0 then return 0 end return u/1000 end end do local L=u.SpellProjectileSpeed local b=N.SpecID_ClassesSpecs function o.FilterProjectileSpeed(u,N)local O={}for N,u in s(o[b[N][1]])do for N,u in s(u)do local b=u:ID()local y=L[b]if y~=nil then O[b]=y end end end L=O end function o.TravelTime(u,N)local b=u:ID()local O=L[b]if not O or O==0 then return 0 end local y=N and N:MaxDistance()or l:MaxDistance()if not y then return 0 end return y/(O or 22)end end function o.IsInFlight(L)return h()<L.LastHitTime end