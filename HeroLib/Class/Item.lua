local t,F=...local e=HeroDBC.DBC local B=HeroCache local a=F.Unit local m=a.Player local O=a.Target local v=F.Spell local w=F.Item local s=C_Item.GetDetailedItemLevelInfo local o=C_Item.GetItemCooldown local c=C_Item.GetItemCount local f=C_Item.GetItemInfo local V=C_Item.GetItemLink local h=C_Item.IsUsableItem local x=GetSpellBaseCooldown local z=ItemLocation local D=GetTime function w.ID(t)return t.ItemID end function w.Name(t)return t.ItemName end function w.Rarity(t)return t.ItemRarity end function w.Level(t)if not t:IsEquipped()then return t.ItemLevel or 0 end local F=m:GetEquipment()for e,B in pairs(t:SlotIDs())do if t:ID()==F[B]then local F=z:CreateFromEquipmentSlot(B)local e=V(F)return s(e)or t.ItemLevel or 0 end end return t.ItemLevel or 0 end function w.MinLevel(t)return t.ItemMinLevel end function w.SlotIDs(t)return t.ItemSlotIDs end function w.InfoByID(t)return f(t:ID())end function w.InfoByName(t)return f(t:Name())end function w.IsLegendary(t)return t.ItemRarity==5 end function w.Exists(t)return c(t:ID())>0 end function w.IsUsable(t)return h(t:ID())end function w.OnUseSpell(t)return t.ItemUseSpell end function w.IsEquipped(t)local F=t:SlotIDs()if not F then return false end local e=t:ID()local a=B.ItemInfo[e]if not a then a={}B.SpellInfo[e]=a end if a.IsEquipped==nil then local e=false local B=m:GetEquipment()for a=0,#F,1 do local m=F[a]if B[m]==t.ItemID then e=true break end end a.IsEquipped=e end return a.IsEquipped end function w.Cooldown(t)return e.ItemSpell[t:ID()]and x(e.ItemSpell[t:ID()])/1000 or 0 end function w.CooldownInfo(t)return o(t:ID())end do local function t(t)local e,B=t:CooldownInfo()if e==0 then return 0 end local a=((e+B)-D())-F.Latency()return a>0 and a or 0 end function w.CooldownRemains(F)local e=F:ID()local a=B.ItemInfo[e]if not a then a={}B.SpellInfo[e]=a end local m=a.Cooldown if not m then m=t(F)a.Cooldown=m end return m end end function w.HasCooldown(t)return t:Cooldown()>0 end function w.CooldownUp(t)return t:CooldownRemains()==0 end function w.CooldownDown(t)return t:CooldownRemains()~=0 end function w.CastTime(t)if not t:OnUseSpell()then return 0 end return(t:OnUseSpell()):CastTime()or 0 end function w.IsReady(t)if not t:IsUsable()or not t:OnUseSpell()then return false end return t:CooldownUp()or t:CooldownRemains()<=m:GCDRemains()end function w.IsEquippedAndReady(t)return t:IsEquipped()and t:IsReady()end function w.TimeSinceLastCast(t)return t:OnUseSpell()and(t:OnUseSpell()):TimeSinceLastCast()or 0 end function w.HasStatAnyDps(t)if not t:OnUseSpell()then return false end return e.SpellAuraStat[(t:OnUseSpell()):ID()]end function w.HasUseBuff(t)return t:IsUsable()and t:HasStatAnyDps()end function w.BuffDuration(t)if not t:IsUsable()then return 0 end if not t:OnUseSpell()then return 0 end local F if e.SpellDuration[(t:OnUseSpell()):ID()]then F=e.SpellDuration[(t:OnUseSpell()):ID()][1]end if not F then return 0 end if F>1000 then F=F/1000 end return F end