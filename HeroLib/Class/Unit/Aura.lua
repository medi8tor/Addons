local L,N=...local u,b=HeroCache,N.Utils local O=N.Unit local y,P,H=O.Player,O.Pet,O.Target local l,f=O.Focus,O.MouseOver local j,e,W=O.Arena,O.Boss,O.Nameplate local r,S=O.Party,O.Raid local M=N.Spell local o=N.Item local t=C_UnitAuras.GetAuraDataByIndex local h=C_UnitAuras.GetPlayerAuraBySpellID local s=GetTime do local L,N,u local b,P,H,l,f function O.AuraInfo(W,O,j,e)L=W:GUID()if not L then return end N=O:ID()if L==y:GUID()then if e then return h(N)else local L=h(N)if type(L)~="\116\097\098\108\101"then return nil end P=L.duration H=L.expirationTime b=L.applications return b,P,H end end u=W:ID()f=1 while true do local L=t(u,f,j)if type(L)~="\116\097\098\108\101"then return end b=L.applications P=L.duration H=L.expirationTime l=L.spellId if not l then return end if l==N then if e then return t(u,f,j)else return b,P,H,f end end f=f+1 end end end function O.BuffInfo(b,L,N,u)local O=N and"\072\069\076\080\070\085\076"or"\072\069\076\080\070\085\076\124\080\076\065\089\069\082"return b:AuraInfo(L,O,u)end function O.BuffStack(b,L,N,u)if not u and b:BuffDown(L,N,u)then return 0 end local O=b:BuffInfo(L,N)return O or 0 end function O.BuffDuration(u,L,N)local b,O=u:BuffInfo(L,N)return O or 0 end function O.BuffRemains(O,L,u,b)local y,P,H=O:BuffInfo(L,u)if not H then return 0 end if H==0 then return 9999 end local l=L:ID()if l==115192 or l==256735 then H=H-.3 end local f=(H-s())-N.RecoveryOffset(b)return f>=0 and f or 0 end function O.BuffUp(b,L,N,u)return b:BuffRemains(L,N,u)>0 end function O.BuffDown(b,L,N,u)return not b:BuffUp(L,N,u)end function O.BuffRefreshable(b,L,N,u)local O=L:PandemicThreshold()return b:BuffRemains(L,N,u)<=O end function O.BuffTicksRemain(b,L,N,u)local O=b:BuffRemains(L,N,u)if O==0 then return 0 end return math.ceil(O/L:TickTime())end function O.DebuffInfo(b,L,N,u)local O=N and"\072\065\082\077\070\085\076"or"\072\065\082\077\070\085\076\124\080\076\065\089\069\082"return b:AuraInfo(L,O,u)end function O.DebuffStack(b,L,N,u)if not u and b:DebuffDown(L,N,u)then return 0 end local O=b:DebuffInfo(L,N)return O or 0 end function O.DebuffDuration(u,L,N)local b,O=u:DebuffInfo(L,N)return O or 0 end function O.DebuffRemains(O,L,u,b)local y,P,H=O:DebuffInfo(L,u)if not H then return 0 end if H==0 then return 9999 end local l=(H-s())-N.RecoveryOffset(b)return l>=0 and l or 0 end function O.DebuffUp(b,L,N,u)return b:DebuffRemains(L,N,u)>0 end function O.DebuffDown(b,L,N,u)return not b:DebuffUp(L,N,u)end function O.DebuffRefreshable(O,L,N,u,b)local y=N or L:PandemicThreshold()return O:DebuffRemains(L,u,b)<=y end function O.DebuffTicksRemain(b,L,N,u)local O=b:DebuffRemains(L,N,u)if O==0 then return 0 end return math.ceil(O/L:TickTime())end do local L={M(2825);M(32182);M(80353);M(90355);M(160452),M(264667),M(390386),M(35475);M(35476),M(146555);M(178207);M(230935);M(256740);M(309658);M(381301),M(444257)}function O.BloodlustRemains(u,N)local b=u:GUID()if not b then return false end for b=1,#L,1 do local O=L[b]if u:BuffUp(O,nil)then return u:BuffRemains(O,nil,N)end end return 0 end function O.BloodlustUp(N,L)return N:BloodlustRemains(L)>0 end function O.BloodlustDown(N,L)return not N:BloodlustUp(L)end end do local L={M(10060)}function O.PowerInfusionRemains(u,N)local b=u:GUID()if not b then return false end for b=1,#L,1 do local O=L[b]if u:BuffUp(O,nil)then return u:BuffRemains(O,nil,N)end end return 0 end function O.PowerInfusionUp(N,L)return N:PowerInfusionRemains(L)>0 end function O.PowerInfusionDown(N,L)return not N:PowerInfusionUp(L)end end do local L={M(57724);M(57723),M(80354),M(264689),M(390435)}function O.BloodlustExhaustRemains(u,N)local b=u:GUID()if not b then return false end for b=1,#L,1 do local O=L[b]if u:DebuffUp(O,nil)then return u:DebuffRemains(O,nil,N)end end return 0 end function O.BloodlustExhaustUp(N,L)return N:BloodlustExhaustRemains(L)>0 end function O.BloodlustExhaustDown(N,L)return not N:BloodlustExhaustUp(L)end end do local L={M(382530);M(388691);M(397383)}function O.EnemyAbsorb(N)for u=1,#L,1 do local b=L[u]if N:BuffUp(b,true)then return true end end return false end end