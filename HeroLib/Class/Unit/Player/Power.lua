local c,W=...local e,N=HeroCache,W.Utils local o=W.Unit local t,q,d=o.Player,o.Pet,o.Target local K,J=o.Focus,o.MouseOver local v,P,h=o.Arena,o.Boss,o.Nameplate local O,k=o.Party,o.Raid local V=W.Spell local l=W.Item local R=Enum local m=GetPowerRegen local H=UnitPower local I=UnitPowerMax local w=GetTime local E=pairs local M=table.sort do local c=R.PowerType.Mana function t.ManaMax(W)return I(W.UnitID,c)end function t.Mana(W)return H(W.UnitID,c)end function t.ManaPercentage(c)return(c:Mana()/c:ManaMax())*100 end function t.ManaDeficit(c)return c:ManaMax()-c:Mana()end function t.ManaDeficitPercentage(c)return(c:ManaDeficit()/c:ManaMax())*100 end function t.ManaRegen(c)return m(c.UnitID)end function t.ManaCastRegen(W,c)if W:ManaRegen()==0 then return-1 end return W:ManaRegen()*c end function t.ManaRemainingCastRegen(W,c)if W:ManaRegen()==0 then return-1 end if W:IsCasting()then return W:ManaRegen()*(W:CastRemains()+(c or 0))else return W:ManaRegen()*(W:GCDRemains()+(c or 0))end end function t.ManaTimeToMax(c)if c:ManaRegen()==0 then return-1 end return c:ManaDeficit()/c:ManaRegen()end function t.ManaTimeToX(W,c)if W:ManaRegen()==0 then return-1 end return c>W:Mana()and(c-W:Mana())/W:ManaRegen()or 0 end function t.ManaP(c)local W=t:Mana()-t:CastCost()if t:Mana()~=t:ManaMax()then W=W+t:ManaRemainingCastRegen()end if W>t:ManaMax()then W=t:ManaMax()end return W end function t.ManaPercentageP(c)return(c:ManaP()/c:ManaMax())*100 end function t.ManaDeficitP(c)return c:ManaMax()-c:ManaP()end function t.ManaDeficitPercentageP(c)return(c:ManaDeficitP()/c:ManaMax())*100 end end do local c=R.PowerType.Rage function t.RageMax(W)return I(W.UnitID,c)end function t.Rage(W)return H(W.UnitID,c)end function t.RagePercentage(c)return(c:Rage()/c:RageMax())*100 end function t.RageDeficit(c)return c:RageMax()-c:Rage()end function t.RageDeficitPercentage(c)return(c:RageDeficit()/c:RageMax())*100 end end do local c=R.PowerType.Focus function t.FocusMax(W)return I(W.UnitID,c)end function t.Focus(W)return H(W.UnitID,c)end function t.FocusRegen(c)return m(c.UnitID)end function t.FocusPercentage(c)return(c:Focus()/c:FocusMax())*100 end function t.FocusDeficit(c)return c:FocusMax()-c:Focus()end function t.FocusDeficitPercentage(c)return(c:FocusDeficit()/c:FocusMax())*100 end function t.FocusRegenPercentage(c)return(c:FocusRegen()/c:FocusMax())*100 end function t.FocusTimeToMax(c)if c:FocusRegen()==0 then return-1 end return c:FocusDeficit()/c:FocusRegen()end function t.FocusTimeToX(W,c)if W:FocusRegen()==0 then return-1 end return c>W:Focus()and(c-W:Focus())/W:FocusRegen()or 0 end function t.FocusTimeToXPercentage(W,c)if W:FocusRegen()==0 then return-1 end return c>W:FocusPercentage()and(c-W:FocusPercentage())/W:FocusRegenPercentage()or 0 end function t.FocusCastRegen(W,c)if W:FocusRegen()==0 then return-1 end return W:FocusRegen()*c end function t.FocusRemainingCastRegen(W,c)if W:FocusRegen()==0 then return-1 end if W:IsCasting()then return W:FocusRegen()*(W:CastRemains()+(c or 0))else return W:FocusRegen()*(W:GCDRemains()+(c or 0))end end function t.FocusLossOnCastEnd(c)return c:IsCasting()and(V(c:CastSpellID())):Cost()or 0 end function t.FocusPredicted(W,c)if W:FocusRegen()==0 then return-1 end return math.min(t:FocusMax(),(W:Focus()+W:FocusRemainingCastRegen(c))-W:FocusLossOnCastEnd())end function t.FocusDeficitPredicted(W,c)if W:FocusRegen()==0 then return-1 end return t:FocusMax()-W:FocusPredicted(c)end function t.FocusTimeToMaxPredicted(c)if c:FocusRegen()==0 then return-1 end local W=c:FocusDeficitPredicted()if W<=0 then return 0 end return W/c:FocusRegen()end end do local c=R.PowerType.Energy function t.EnergyMax(e,W)return math.max(0,I(e.UnitID,c)+(W or 0))end function t.Energy(W)return H(W.UnitID,c)end function t.EnergyRegen(c)return m(c.UnitID)end function t.EnergyPercentage(W,c)return math.min(100,(W:Energy()/W:EnergyMax(c))*100)end function t.EnergyDeficit(W,c)return math.max(0,W:EnergyMax(c)-W:Energy())end function t.EnergyDeficitPercentage(W,c)return(W:EnergyDeficit(c)/W:EnergyMax(c))*100 end function t.EnergyRegenPercentage(W,c)return(W:EnergyRegen()/W:EnergyMax(c))*100 end function t.EnergyTimeToMax(W,c)if W:EnergyRegen()==0 then return-1 end return W:EnergyDeficit(c)/W:EnergyRegen()end function t.EnergyTimeToX(e,c,W)if e:EnergyRegen()==0 then return-1 end return c>e:Energy()and(c-e:Energy())/(e:EnergyRegen()*(1-(W or 0)))or 0 end function t.EnergyTimeToXPercentage(W,c)if W:EnergyRegen()==0 then return-1 end return c>W:EnergyPercentage()and(c-W:EnergyPercentage())/W:EnergyRegenPercentage()or 0 end function t.EnergyRemainingCastRegen(W,c)if W:EnergyRegen()==0 then return-1 end if W:IsCasting()or W:IsChanneling()then return W:EnergyRegen()*(W:CastRemains()+(c or 0))else return W:EnergyRegen()*(W:GCDRemains()+(c or 0))end end function t.EnergyPredicted(e,c,W)if e:EnergyRegen()==0 then return-1 end return math.min(t:EnergyMax(W),e:Energy()+e:EnergyRemainingCastRegen(c))end function t.EnergyDeficitPredicted(e,c,W)if e:EnergyRegen()==0 then return-1 end return math.max(0,e:EnergyDeficit(W)-e:EnergyRemainingCastRegen(c))end function t.EnergyTimeToMaxPredicted(e,c,W)if e:EnergyRegen()==0 then return-1 end local N=e:EnergyDeficitPredicted(c,W)if N<=0 then return 0 end return N/e:EnergyRegen()end end do local c=R.PowerType.ComboPoints function t.ComboPointsMax(W)return I(W.UnitID,c)end function t.ComboPoints(W)return H(W.UnitID,c)end function t.ComboPointsDeficit(c)return c:ComboPointsMax()-c:ComboPoints()end end do local c=R.PowerType.RunicPower function t.RunicPowerMax(W)return I(W.UnitID,c)end function t.RunicPower(W)return H(W.UnitID,c)end function t.RunicPowerPercentage(c)return(c:RunicPower()/c:RunicPowerMax())*100 end function t.RunicPowerDeficit(c)return c:RunicPowerMax()-c:RunicPower()end function t.RunicPowerDeficitPercentage(c)return(c:RunicPowerDeficit()/c:RunicPowerMax())*100 end end do local c=GetRuneCooldown local function e(e,N)local o,t=c(e)if o==0 or o==nil then return 0 end local q=((o+t)-w())-W.RecoveryOffset(N)return q>0 and q or 0 end function t.Rune(c)local W=0 for c=1,6,1 do if e(c)==0 then W=W+1 end end return W end function t.RuneTimeToX(W,c)if type(c)~="\110\117\109\098\101\114"then error("\086\097\108\117\101 \109\117\115\116 \098\101 \097 \110\117\109\098\101\114\046")end if c<1 or c>6 then error("\086\097\108\117\101 \109\117\115\116 \098\101 \097 \110\117\109\098\101\114 \098\101\116\119\101\101\110 \049 \097\110\100 \054\046")end local N={}for c=1,6,1 do N[c]=e(c)end M(N,function(c,W)return c<W end)local o=1 for W,e in E(N)do if o==c then return e end o=o+1 end end end do local c=R.PowerType.SoulShards function t.SoulShardsMax(W)return I(W.UnitID,c)end function t.SoulShards(W)return H(W.UnitID,c)end function t.SoulShardsP(W)return H(W.UnitID,c)end function t.SoulShardsDeficit(c)return c:SoulShardsMax()-c:SoulShards()end end do local c=R.PowerType.LunarPower function t.AstralPowerMax(W)return I(W.UnitID,c)end function t.AstralPower(e,W)return W or H(e.UnitID,c)end function t.AstralPowerPercentage(W,c)return(W:AstralPower(c)/W:AstralPowerMax())*100 end function t.AstralPowerDeficit(W,c)local e=W:AstralPower(c)return W:AstralPowerMax()-e end function t.AstralPowerDeficitPercentage(W,c)return(W:AstralPowerDeficit(c)/W:AstralPowerMax())*100 end end do local c=R.PowerType.HolyPower function t.HolyPowerMax(W)return I(W.UnitID,c)end function t.HolyPower(W)return H(W.UnitID,c)end function t.HolyPowerPercentage(c)return(c:HolyPower()/c:HolyPowerMax())*100 end function t.HolyPowerDeficit(c)return c:HolyPowerMax()-c:HolyPower()end function t.HolyPowerDeficitPercentage(c)return(c:HolyPowerDeficit()/c:HolyPowerMax())*100 end end function t.MaelstromMax(c)return I(c.UnitID,R.PowerType.Maelstrom)end function t.Maelstrom(c)return H(c.UnitID,R.PowerType.Maelstrom)end function t.MaelstromPercentage(c)return(c:Maelstrom()/c:MaelstromMax())*100 end function t.MaelstromDeficit(c)return c:MaelstromMax()-c:Maelstrom()end function t.MaelstromDeficitPercentage(c)return(c:MaelstromDeficit()/c:MaelstromMax())*100 end do local c=R.PowerType.Chi local W=UnitStagger function t.ChiMax(W)return I(W.UnitID,c)end function t.Chi(W)return H(W.UnitID,c)end function t.ChiPercentage(c)return(c:Chi()/c:ChiMax())*100 end function t.ChiDeficit(c)return c:ChiMax()-c:Chi()end function t.ChiDeficitPercentage(c)return(c:ChiDeficit()/c:ChiMax())*100 end function t.StaggerMax(c)return c:MaxHealth()end function t.Stagger(c)return W(c.UnitID)end function t.StaggerPercentage(c)return(c:Stagger()/c:StaggerMax())*100 end end do local c=R.PowerType.Insanity function t.InsanityMax(W)return I(W.UnitID,c)end function t.Insanity(W)return H(W.UnitID,c)end function t.InsanityPercentage(c)return(c:Insanity()/c:InsanityMax())*100 end function t.InsanityDeficit(c)return c:InsanityMax()-c:Insanity()end function t.InsanityDeficitPercentage(c)return(c:InsanityDeficit()/c:InsanityMax())*100 end function t.Insanityrain(c)return 1 end end do local c=R.PowerType.ArcaneCharges function t.ArcaneChargesMax(W)return I(W.UnitID,c)end function t.ArcaneCharges(W)return H(W.UnitID,c)end function t.ArcaneChargesPercentage(c)return(c:ArcaneCharges()/c:ArcaneChargesMax())*100 end function t.ArcaneChargesDeficit(c)return c:ArcaneChargesMax()-c:ArcaneCharges()end function t.ArcaneChargesDeficitPercentage(c)return(c:ArcaneChargesDeficit()/c:ArcaneChargesMax())*100 end end do local c=R.PowerType.Fury function t.FuryMax(W)return I(W.UnitID,c)end function t.Fury(W)return H(W.UnitID,c)end function t.FuryPercentage(c)return(c:Fury()/c:FuryMax())*100 end function t.FuryDeficit(c)return c:FuryMax()-c:Fury()end function t.FuryDeficitPercentage(c)return(c:FuryDeficit()/c:FuryMax())*100 end end do local c=R.PowerType.Pain function t.PainMax(W)return I(W.UnitID,c)end function t.Pain(W)return H(W.UnitID,c)end function t.PainPercentage(c)return(c:Pain()/c:PainMax())*100 end function t.PainDeficit(c)return c:PainMax()-c:Pain()end function t.PainDeficitPercentage(c)return(c:PainDeficit()/c:PainMax())*100 end end do local c=R.PowerType.Essence function t.EssenceMax(W)return I(W.UnitID,c)end function t.Essence(W)return H(W.UnitID,c)end function t.EssenceDeficit(c)return c:EssenceMax()-c:Essence()end end do t.PredictedResourceMap={[-2]=function()return t:Health()end;[0]=function()return t:ManaP()end,[1]=function()return t:Rage()end;[2]=function()return t:FocusPredicted()end;[3]=function()return t:EnergyPredicted()end;[4]=function()return t:ComboPoints()end;[5]=function()return t:Rune()end;[6]=function()return t:RunicPower()end;[7]=function()return t:SoulShardsP()end,[8]=function()return t:AstralPower()end;[9]=function()return t:HolyPower()end;[11]=function()return t:Maelstrom()end;[12]=function()return t:Chi()end,[13]=function()return t:Insanity()end,[16]=function()return t:ArcaneCharges()end,[17]=function()return t:Fury()end,[18]=function()return t:Pain()end;[19]=function()return t:Essence()end}end do t.TimeToXResourceMap={[0]=function(c)return t:ManaTimeToX(c)end;[1]=function()return nil end;[2]=function(c)return t:FocusTimeToX(c)end;[3]=function(c)return t:EnergyTimeToX(c)end;[4]=function()return nil end;[5]=function()return nil end;[6]=function(c)return t:RuneTimeToX(c)end,[7]=function()return nil end;[8]=function()return nil end;[9]=function()return nil end;[11]=function()return nil end,[12]=function()return nil end;[13]=function()return nil end,[16]=function()return nil end;[17]=function()return nil end;[18]=function()return nil end;[19]=function()return nil end}end