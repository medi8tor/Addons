local G,U=...local h=HeroCache local w,i=U.Unit,U.UnitGUIDMap local Z=w.Player local M=w.Pet local d=w.Target local O=w.Nameplate local c=U.Spell local C=U.Item local H=pairs local W=table.insert local k={}function c.RegisterAuraTracking(G)local h=G:ID()if k[h]then error("\065\116\116\101\109\112\116\101\100 \116\111 \114\101\103\105\115\116\101\114 \115\112\101\108\108 "..(h.." \109\117\108\116\105\112\108\101 \116\105\109\101\115\044 \097\098\111\114\116\105\110\103\033"))end k[h]={Spell=G,Units={}}U.Debug("\082\101\103\105\115\116\101\114\065\117\114\097\084\114\097\099\107\105\110\103 "..h)end function U.UnregisterAuraTracking()U.Debug("\085\110\114\101\103\105\115\116\101\114\065\117\114\097\084\114\097\099\107\105\110\103\040\041")k={}end U:RegisterForSelfCombatEvent(function(G,U,h,w,i,Z,M,d,O,c,C,H)local W=k[H]if not W then return end local Y=W.Units if not Y[d]then Y[d]=true else end end,"\083\080\069\076\076\095\065\085\082\065\095\065\080\080\076\073\069\068","\083\080\069\076\076\095\065\085\082\065\095\082\069\070\082\069\083\072","\083\080\069\076\076\095\065\085\082\065\095\065\080\080\076\073\069\068\095\068\079\083\069")U:RegisterForSelfCombatEvent(function(G,U,h,w,i,Z,M,d,O,c,C,H)local W=k[H]if not W then return end local Y=W.Units if Y[d]then Y[d]=nil end end,"\083\080\069\076\076\095\065\085\082\065\095\082\069\077\079\086\069\068")U:RegisterForCombatEvent(function(G,U,h,w,i,Z,M,d)for G,U in H(k)do local h=U.Units if h[d]then h[d]=nil end end end,"\085\078\073\084\095\068\073\069\068","\085\078\073\084\095\068\069\083\084\082\079\089\069\068")do local function G(G)local U=G:GUID()if not U then return end for h,w in H(k)do local i=w.Spell local Z=w.Units if G:DebuffUp(i,nil,true)or G:BuffUp(i,nil,true)then if not Z[U]then Z[U]=true end else if Z[U]then Z[U]=nil end end end end U:RegisterForEvent(function(U,h)G(O[h])end,"\078\065\077\069\095\080\076\065\084\069\095\085\078\073\084\095\065\068\068\069\068")U:RegisterForEvent(function()G(d)end,"\080\076\065\089\069\082\095\084\065\082\071\069\084\095\067\072\065\078\071\069\068")end do local function G(G)return"\089\111\117 \102\111\114\103\111\116 \116\111 \114\101\103\105\115\116\101\114 \116\104\101 \115\112\101\108\108\058 "..G:Name()or G:ID().." \105\110 \082\101\103\105\115\116\101\114\065\117\114\097 \104\097\110\100\108\101\114\046"end local function U(G,U)if i[U]then for G,U in H(i[U])do if U then return U end end end G[U]=nil return nil end function c.AuraActiveCount(h)local w=k[h:ID()]if not w then error(G(h))end local i=0 local Z=w.Units for G,h in H(Z)do if U(Z,G)then i=i+1 end end return i end function c.AuraActiveUnits(h)local w=k[h:ID()]if not w then error(G(h))end local i={}local Z=w.Units for G,h in H(Z)do local w=U(Z,G)if w then W(i,w)end end return i end function c.AnyBuffUp(w,h)local i=k[w:ID()]if not i then error(G(w))end local Z=i.Units for G,i in H(Z)do local M=U(Z,G)if M and M:Buff(w,nil,h)then return true end end return false end function c.AnyDebuffUp(w,h)local i=k[w:ID()]if not i then error(G(w))end local Z=i.Units for G,i in H(Z)do local M=U(Z,G)if M and M:DebuffUp(w,nil,h)then return true end end return false end function c.MaxDebuffRemains(w,h)local i=k[w:ID()]if not i then error(G(w))end local Z=0 local M=i.Units for G,i in H(M)do local d=U(M,G)if d then Z=math.max(Z,d:DebuffRemains(w,nil,h))end end return Z end function c.MaxDebuffRemainsUnit(w,h)local i=k[w:ID()]if not i then error(G(w))end local Z,M=0,nil local d=i.Units for G,i in H(d)do local O=U(d,G)if O then local G=O:DebuffRemains(w,nil,h)if G>Z then Z=G M=O end end end return M end function c.MaxDebuffStack(w,h)local i=k[w:ID()]if not i then error(G(w))end local Z=0 local M=i.Units for G,i in H(M)do local d=U(M,G)if d then Z=math.max(Z,d:DebuffStack(w,nil,h))end end return Z end function c.MaxDebuffStackUnit(w,h)local i=k[w:ID()]if not i then error(G(w))end local Z,M=0,nil local d=i.Units for G,i in H(d)do local O=U(d,G)if O then local G=O:DebuffStack(w,nil,h)if G>Z then Z=G M=O end end end return M end end